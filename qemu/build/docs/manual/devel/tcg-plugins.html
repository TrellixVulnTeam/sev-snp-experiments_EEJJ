

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>QEMU TCG Plugins &mdash; QEMU  documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/qemu_32x32.png"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bitwise operations" href="bitops.html" />
    <link rel="prev" title="Multi-threaded TCG" href="multi-thread-tcg.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >
          

          
            <a href="../index.html" class="icon icon-home"> QEMU
          

          
            
            <img src="../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                6.1.50
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">About QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Information</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="code-of-conduct.html">Code of Conduct</a></li>
<li class="toctree-l2"><a class="reference internal" href="conflict-resolution.html">Conflict Resolution Policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system.html">The QEMU build system architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="style.html">QEMU Coding Style</a></li>
<li class="toctree-l2"><a class="reference internal" href="kconfig.html">QEMU and Kconfig</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing.html">Testing in QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="fuzzing.html">Fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow-integrity.html">Control-Flow Integrity (CFI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="loads-stores.html">Load and Store APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">The memory API</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="atomics.html">Atomic operations in QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="stable-process.html">QEMU and the stable process</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">CI</a></li>
<li class="toctree-l2"><a class="reference internal" href="qtest.html">QTest Device Emulation Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="decodetree.html">Decodetree Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="secure-coding-practices.html">Secure Coding Practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcg.html">Translator Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcg-icount.html">TCG Instruction Counting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tracing.html">Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-thread-tcg.html">Multi-threaded TCG</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">QEMU TCG Plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-plugins">Writing plugins</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#api-versioning">API versioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lifetime-of-the-query-handle">Lifetime of the query handle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plugin-life-cycle">Plugin life cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exposure-of-qemu-internals">Exposure of QEMU internals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#internals">Internals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#locking">Locking</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-plugins">Example Plugins</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bitops.html">Bitwise operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ui.html">Qemu UI subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="reset.html">Reset in QEMU: the Resettable interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-dasd-ipl.html">Booting from real channel-attached devices on s390x</a></li>
<li class="toctree-l2"><a class="reference internal" href="clocks.html">Modelling a clock tree in QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="qom.html">The QEMU Object Model (QOM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Qemu modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="block-coroutine-wrapper.html">block-coroutine-wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi-process.html">Multi-process QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="ebpf_rss.html">eBPF RSS virtio-net support</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-migration.html">VFIO device Migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="qapi-code-gen.html">How to use the QAPI code generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing-qmp-commands.html">How to write QMP commands using the QAPI framework</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QEMU</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Developer Information</a> &raquo;</li>
        
      <li>QEMU TCG Plugins</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://gitlab.com/qemu-project/qemu/blob/master/docs/devel/tcg-plugins.rst" class="fa fa-gitlab"> Edit on GitLab</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="qemu-tcg-plugins">
<h1>QEMU TCG Plugins<a class="headerlink" href="#qemu-tcg-plugins" title="Permalink to this headline">Â¶</a></h1>
<p>QEMU TCG plugins provide a way for users to run experiments taking
advantage of the total system control emulation can have over a guest.
It provides a mechanism for plugins to subscribe to events during
translation and execution and optionally callback into the plugin
during these events. TCG plugins are unable to change the system state
only monitor it passively. However they can do this down to an
individual instruction granularity including potentially subscribing
to all load and store operations.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">Â¶</a></h2>
<p>Any QEMU binary with TCG support has plugins enabled by default.
Earlier releases needed to be explicitly enabled with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">configure</span> <span class="o">--</span><span class="n">enable</span><span class="o">-</span><span class="n">plugins</span>
</pre></div>
</div>
<p>Once built a program can be run with multiple plugins loaded each with
their own arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$QEMU $OTHER_QEMU_ARGS \
    -plugin tests/plugin/libhowvec.so,inline=on,count=hint \
    -plugin tests/plugin/libhotblocks.so
</pre></div>
</div>
<p>Arguments are plugin specific and can be used to modify their
behaviour. In this case the howvec plugin is being asked to use inline
ops to count and break down the hint instructions by type.</p>
</div>
<div class="section" id="writing-plugins">
<h2>Writing plugins<a class="headerlink" href="#writing-plugins" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="api-versioning">
<h3>API versioning<a class="headerlink" href="#api-versioning" title="Permalink to this headline">Â¶</a></h3>
<p>This is a new feature for QEMU and it does allow people to develop
out-of-tree plugins that can be dynamically linked into a running QEMU
process. However the project reserves the right to change or break the
API should it need to do so. The best way to avoid this is to submit
your plugin upstream so they can be updated if/when the API changes.</p>
<p>All plugins need to declare a symbol which exports the plugin API
version they were built against. This can be done simply by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QEMU_PLUGIN_EXPORT</span> <span class="nb">int</span> <span class="n">qemu_plugin_version</span> <span class="o">=</span> <span class="n">QEMU_PLUGIN_VERSION</span><span class="p">;</span>
</pre></div>
</div>
<p>The core code will refuse to load a plugin that doesnât export a
<code class="docutils literal notranslate"><span class="pre">qemu_plugin_version</span></code> symbol or if plugin version is outside of QEMUâs
supported range of API versions.</p>
<p>Additionally the <code class="docutils literal notranslate"><span class="pre">qemu_info_t</span></code> structure which is passed to the
<code class="docutils literal notranslate"><span class="pre">qemu_plugin_install</span></code> method of a plugin will detail the minimum and
current API versions supported by QEMU. The API version will be
incremented if new APIs are added. The minimum API version will be
incremented if existing APIs are changed or removed.</p>
</div>
<div class="section" id="lifetime-of-the-query-handle">
<h3>Lifetime of the query handle<a class="headerlink" href="#lifetime-of-the-query-handle" title="Permalink to this headline">Â¶</a></h3>
<p>Each callback provides an opaque anonymous information handle which
can usually be further queried to find out information about a
translation, instruction or operation. The handles themselves are only
valid during the lifetime of the callback so it is important that any
information that is needed is extracted during the callback and saved
by the plugin.</p>
</div>
<div class="section" id="plugin-life-cycle">
<h3>Plugin life cycle<a class="headerlink" href="#plugin-life-cycle" title="Permalink to this headline">Â¶</a></h3>
<p>First the plugin is loaded and the public qemu_plugin_install function
is called. The plugin will then register callbacks for various plugin
events. Generally plugins will register a handler for the <em>atexit</em>
if they want to dump a summary of collected information once the
program/system has finished running.</p>
<p>When a registered event occurs the plugin callback is invoked. The
callbacks may provide additional information. In the case of a
translation event the plugin has an option to enumerate the
instructions in a block of instructions and optionally register
callbacks to some or all instructions when they are executed.</p>
<p>There is also a facility to add an inline event where code to
increment a counter can be directly inlined with the translation.
Currently only a simple increment is supported. This is not atomic so
can miss counts. If you want absolute precision you should use a
callback which can then ensure atomicity itself.</p>
<p>Finally when QEMU exits all the registered <em>atexit</em> callbacks are
invoked.</p>
</div>
<div class="section" id="exposure-of-qemu-internals">
<h3>Exposure of QEMU internals<a class="headerlink" href="#exposure-of-qemu-internals" title="Permalink to this headline">Â¶</a></h3>
<p>The plugin architecture actively avoids leaking implementation details
about how QEMUâs translation works to the plugins. While there are
conceptions such as translation time and translation blocks the
details are opaque to plugins. The plugin is able to query select
details of instructions and system configuration only through the
exported <em>qemu_plugin</em> functions.</p>
</div>
<div class="section" id="api">
<h3>API<a class="headerlink" href="#api" title="Permalink to this headline">Â¶</a></h3>
<dl class="type">
<dt id="c.qemu_plugin_id_t">
typedef <code class="descname">qemu_plugin_id_t</code><a class="headerlink" href="#c.qemu_plugin_id_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Unique plugin ID</p>
</dd></dl>

<dl class="type">
<dt id="c.qemu_info_t">
struct <code class="descname">qemu_info_t</code><a class="headerlink" href="#c.qemu_info_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p>system information for plugins</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">qemu_info_t</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">target_name</span><span class="p">;</span>
  <span class="n">struct</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="nb">min</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">cur</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">version</span><span class="p">;</span>
  <span class="nb">bool</span> <span class="n">system_emulation</span><span class="p">;</span>
  <span class="n">union</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="p">{</span>
      <span class="nb">int</span> <span class="n">smp_vcpus</span><span class="p">;</span>
      <span class="nb">int</span> <span class="n">max_vcpus</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">system</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">target_name</span></code></dt>
<dd>string describing architecture</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt>
<dd>minimum and current plugin API level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system_emulation</span></code></dt>
<dd>is this a full system emulation?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system</span></code></dt>
<dd>information relevant to system emulation</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides for some limited information about the
system to allow the plugin to make decisions on how to proceed. For
example it might only be suitable for running on some guest
architectures or when under full system emulation.</p>
<dl class="function">
<dt id="c.qemu_plugin_install">
int <code class="descname">qemu_plugin_install</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, const <a class="reference internal" href="#c.qemu_info_t" title="qemu_info_t">qemu_info_t</a><em>&nbsp;*info</em>, int<em>&nbsp;argc</em>, char<em>&nbsp;**argv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_install" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Install a plugin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>this pluginâs opaque ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">qemu_info_t</span> <span class="pre">*info</span></code></dt>
<dd>a block describing some details about the guest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">argc</span></code></dt>
<dd>number of arguments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**argv</span></code></dt>
<dd>array of arguments (<strong>argc</strong> elements)</dd>
</dl>
<p><strong>Description</strong></p>
<p>All plugins must export this symbol which is called when the plugin
is first loaded. Calling qemu_plugin_uninstall() from this function
is a bug.</p>
<p><strong>Note</strong></p>
<p><strong>info</strong> is only live during the call. Copy any information we
want to keep. <strong>argv</strong> remains valid throughout the lifetime of the
loaded plugin.</p>
<p><strong>Return</strong></p>
<p>0 on successful loading, !0 for an error.</p>
<dl class="type">
<dt id="c.qemu_plugin_simple_cb_t">
<code class="descname">qemu_plugin_simple_cb_t</code><a class="headerlink" href="#c.qemu_plugin_simple_cb_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p><strong>Typedef</strong>: simple callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_simple_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id)</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>the unique qemu_plugin_id_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>This callback passes no information aside from the unique <strong>id</strong>.</p>
<dl class="type">
<dt id="c.qemu_plugin_udata_cb_t">
<code class="descname">qemu_plugin_udata_cb_t</code><a class="headerlink" href="#c.qemu_plugin_udata_cb_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p><strong>Typedef</strong>: callback with user data</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_udata_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id,</span> <span class="pre">void</span> <span class="pre">*userdata)</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>the unique qemu_plugin_id_t</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt>
<dd>a pointer to some user data supplied when the callback
was registered.</dd>
</dl>
<dl class="type">
<dt id="c.qemu_plugin_vcpu_simple_cb_t">
<code class="descname">qemu_plugin_vcpu_simple_cb_t</code><a class="headerlink" href="#c.qemu_plugin_vcpu_simple_cb_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p><strong>Typedef</strong>: vcpu callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index)</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>the unique qemu_plugin_id_t</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index</span></code></dt>
<dd>the current vcpu context</dd>
</dl>
<dl class="type">
<dt id="c.qemu_plugin_vcpu_udata_cb_t">
<code class="descname">qemu_plugin_vcpu_udata_cb_t</code><a class="headerlink" href="#c.qemu_plugin_vcpu_udata_cb_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p><strong>Typedef</strong>: vcpu callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_vcpu_udata_cb_t</span> <span class="pre">(unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index,</span> <span class="pre">void</span> <span class="pre">*userdata)</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vcpu_index</span></code></dt>
<dd>the current vcpu context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt>
<dd>a pointer to some user data supplied when the callback
was registered.</dd>
</dl>
<dl class="function">
<dt id="c.qemu_plugin_uninstall">
void <code class="descname">qemu_plugin_uninstall</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_simple_cb_t" title="qemu_plugin_simple_cb_t">qemu_plugin_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_uninstall" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uninstall a plugin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>this pluginâs opaque ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback to be called once the plugin has been removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do NOT assume that the plugin has been uninstalled once this function
returns. Plugins are uninstalled asynchronously, and therefore the given
plugin receives callbacks until <strong>cb</strong> is called.</p>
<p><strong>Note</strong></p>
<p>Calling this function from qemu_plugin_install() is a bug.</p>
<dl class="function">
<dt id="c.qemu_plugin_reset">
void <code class="descname">qemu_plugin_reset</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_simple_cb_t" title="qemu_plugin_simple_cb_t">qemu_plugin_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_reset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reset a plugin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>this pluginâs opaque ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback to be called once the plugin has been reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters all callbacks for the plugin given by <strong>id</strong>.</p>
<p>Do NOT assume that the plugin has been reset once this function returns.
Plugins are reset asynchronously, and therefore the given plugin receives
callbacks until <strong>cb</strong> is called.</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_init_cb">
void <code class="descname">qemu_plugin_register_vcpu_init_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_init_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a vCPU initialization callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU is initialized.</p>
<p>See also: qemu_plugin_register_vcpu_exit_cb()</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_exit_cb">
void <code class="descname">qemu_plugin_register_vcpu_exit_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_exit_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a vCPU exit callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU exits.</p>
<p>See also: qemu_plugin_register_vcpu_init_cb()</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_idle_cb">
void <code class="descname">qemu_plugin_register_vcpu_idle_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_idle_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a vCPU idle callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU idles.</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_resume_cb">
void <code class="descname">qemu_plugin_register_vcpu_resume_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_resume_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a vCPU resume callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a vCPU resumes execution.</p>
<dl class="type">
<dt id="c.qemu_plugin_cb_flags">
enum <code class="descname">qemu_plugin_cb_flags</code><a class="headerlink" href="#c.qemu_plugin_cb_flags" title="Permalink to this definition">Â¶</a></dt>
<dd><p>type of callback</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_CB_NO_REGS</span></code></dt>
<dd>callback does not access the CPUâs regs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_CB_R_REGS</span></code></dt>
<dd>callback reads the CPUâs regs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_CB_RW_REGS</span></code></dt>
<dd>callback reads and writes the CPUâs regs</dd>
</dl>
<p><strong>Note</strong></p>
<p>currently unused, plugins cannot read or change system
register state.</p>
<dl class="type">
<dt id="c.qemu_plugin_vcpu_tb_trans_cb_t">
<code class="descname">qemu_plugin_vcpu_tb_trans_cb_t</code><a class="headerlink" href="#c.qemu_plugin_vcpu_tb_trans_cb_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p><strong>Typedef</strong>: translation callback</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">qemu_plugin_vcpu_tb_trans_cb_t</span> <span class="pre">(qemu_plugin_id_t</span> <span class="pre">id,</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb)</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>unique plugin id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt>
<dd>opaque handle used for querying and instrumenting a block.</dd>
</dl>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_tb_trans_cb">
void <code class="descname">qemu_plugin_register_vcpu_tb_trans_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_tb_trans_cb_t" title="qemu_plugin_vcpu_tb_trans_cb_t">qemu_plugin_vcpu_tb_trans_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_tb_trans_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a translate cb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_tb_trans_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a translation occurs. The <strong>cb</strong>
function is passed an opaque qemu_plugin_type which it can query
for additional information including the list of translated
instructions. At this point the plugin can register further
callbacks to be triggered when the block or individual instruction
executes.</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_tb_exec_cb">
void <code class="descname">qemu_plugin_register_vcpu_tb_exec_cb</code><span class="sig-paren">(</span>struct qemu_plugin_tb<em>&nbsp;*tb</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_udata_cb_t" title="qemu_plugin_vcpu_udata_cb_t">qemu_plugin_vcpu_udata_cb_t</a><em>&nbsp;cb</em>, enum <a class="reference internal" href="#c.qemu_plugin_cb_flags" title="qemu_plugin_cb_flags">qemu_plugin_cb_flags</a><em>&nbsp;flags</em>, void<em>&nbsp;*userdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_tb_exec_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register execution callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt>
<dd>the opaque qemu_plugin_tb handle for the translation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_udata_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_cb_flags</span> <span class="pre">flags</span></code></dt>
<dd>does the plugin read or write the CPUâs registers?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt>
<dd>any plugin data to pass to the <strong>cb</strong>?</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time a translated unit executes.</p>
<dl class="type">
<dt id="c.qemu_plugin_op">
enum <code class="descname">qemu_plugin_op</code><a class="headerlink" href="#c.qemu_plugin_op" title="Permalink to this definition">Â¶</a></dt>
<dd><p>describes an inline op</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">QEMU_PLUGIN_INLINE_ADD_U64</span></code></dt>
<dd>add an immediate value uint64_t</dd>
</dl>
<p><strong>Note</strong></p>
<p>currently only a single inline op is supported.</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_tb_exec_inline">
void <code class="descname">qemu_plugin_register_vcpu_tb_exec_inline</code><span class="sig-paren">(</span>struct qemu_plugin_tb<em>&nbsp;*tb</em>, enum <a class="reference internal" href="#c.qemu_plugin_op" title="qemu_plugin_op">qemu_plugin_op</a><em>&nbsp;op</em>, void<em>&nbsp;*ptr</em>, uint64_t<em>&nbsp;imm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_tb_exec_inline" title="Permalink to this definition">Â¶</a></dt>
<dd><p>execution inline op</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt>
<dd>the opaque qemu_plugin_tb handle for the translation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_op</span> <span class="pre">op</span></code></dt>
<dd>the type of qemu_plugin_op (e.g. ADD_U64)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt>
<dd>the target memory location for the op</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">imm</span></code></dt>
<dd>the op data (e.g. 1)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert an inline op to every time a translated unit executes.
Useful if you just want to increment a single counter somewhere in
memory.</p>
<p><strong>Note</strong></p>
<p>ops are not atomic so in multi-threaded/multi-smp situations
you will get inexact results.</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_insn_exec_cb">
void <code class="descname">qemu_plugin_register_vcpu_insn_exec_cb</code><span class="sig-paren">(</span>struct qemu_plugin_insn<em>&nbsp;*insn</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_udata_cb_t" title="qemu_plugin_vcpu_udata_cb_t">qemu_plugin_vcpu_udata_cb_t</a><em>&nbsp;cb</em>, enum <a class="reference internal" href="#c.qemu_plugin_cb_flags" title="qemu_plugin_cb_flags">qemu_plugin_cb_flags</a><em>&nbsp;flags</em>, void<em>&nbsp;*userdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_insn_exec_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register insn execution cb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>the opaque qemu_plugin_insn handle for an instruction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_udata_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_cb_flags</span> <span class="pre">flags</span></code></dt>
<dd>does the plugin read or write the CPUâs registers?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt>
<dd>any plugin data to pass to the <strong>cb</strong>?</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called every time an instruction is executed</p>
<dl class="function">
<dt id="c.qemu_plugin_register_vcpu_insn_exec_inline">
void <code class="descname">qemu_plugin_register_vcpu_insn_exec_inline</code><span class="sig-paren">(</span>struct qemu_plugin_insn<em>&nbsp;*insn</em>, enum <a class="reference internal" href="#c.qemu_plugin_op" title="qemu_plugin_op">qemu_plugin_op</a><em>&nbsp;op</em>, void<em>&nbsp;*ptr</em>, uint64_t<em>&nbsp;imm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_vcpu_insn_exec_inline" title="Permalink to this definition">Â¶</a></dt>
<dd><p>insn execution inline op</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>the opaque qemu_plugin_insn handle for an instruction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">qemu_plugin_op</span> <span class="pre">op</span></code></dt>
<dd>the type of qemu_plugin_op (e.g. ADD_U64)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt>
<dd>the target memory location for the op</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">imm</span></code></dt>
<dd>the op data (e.g. 1)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert an inline op to every time an instruction executes. Useful
if you just want to increment a single counter somewhere in memory.</p>
<dl class="function">
<dt id="c.qemu_plugin_tb_n_insns">
size_t <code class="descname">qemu_plugin_tb_n_insns</code><span class="sig-paren">(</span>const struct qemu_plugin_tb<em>&nbsp;*tb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_tb_n_insns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>query helper for number of insns in TB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt>
<dd>opaque handle to TB passed to callback</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of instructions in this block</p>
<dl class="function">
<dt id="c.qemu_plugin_tb_vaddr">
uint64_t <code class="descname">qemu_plugin_tb_vaddr</code><span class="sig-paren">(</span>const struct qemu_plugin_tb<em>&nbsp;*tb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_tb_vaddr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>query helper for vaddr of TB start</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt>
<dd>opaque handle to TB passed to callback</dd>
</dl>
<p><strong>Return</strong></p>
<p>virtual address of block start</p>
<dl class="function">
<dt id="c.qemu_plugin_tb_get_insn">
struct qemu_plugin_insn * <code class="descname">qemu_plugin_tb_get_insn</code><span class="sig-paren">(</span>const struct qemu_plugin_tb<em>&nbsp;*tb</em>, size_t<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_tb_get_insn" title="Permalink to this definition">Â¶</a></dt>
<dd><p>retrieve handle for instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_tb</span> <span class="pre">*tb</span></code></dt>
<dd>opaque handle to TB passed to callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt>
<dd>instruction number, 0 indexed</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned handle can be used in follow up helper queries as well
as when instrumenting an instruction. It is only valid for the
lifetime of the callback.</p>
<p><strong>Return</strong></p>
<p>opaque handle to instruction</p>
<dl class="function">
<dt id="c.qemu_plugin_insn_data">
const void * <code class="descname">qemu_plugin_insn_data</code><span class="sig-paren">(</span>const struct qemu_plugin_insn<em>&nbsp;*insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return ptr to instruction data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>opaque instruction handle from qemu_plugin_tb_get_insn()</dd>
</dl>
<p><strong>Note</strong></p>
<p>data is only valid for duration of callback. See
qemu_plugin_insn_size() to calculate size of stream.</p>
<p><strong>Return</strong></p>
<p>pointer to a stream of bytes containing the value of this
instructions opcode.</p>
<dl class="function">
<dt id="c.qemu_plugin_insn_size">
size_t <code class="descname">qemu_plugin_insn_size</code><span class="sig-paren">(</span>const struct qemu_plugin_insn<em>&nbsp;*insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return size of instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>opaque instruction handle from qemu_plugin_tb_get_insn()</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of instruction in bytes</p>
<dl class="function">
<dt id="c.qemu_plugin_insn_vaddr">
uint64_t <code class="descname">qemu_plugin_insn_vaddr</code><span class="sig-paren">(</span>const struct qemu_plugin_insn<em>&nbsp;*insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_vaddr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return vaddr of instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>opaque instruction handle from qemu_plugin_tb_get_insn()</dd>
</dl>
<p><strong>Return</strong></p>
<p>virtual address of instruction</p>
<dl class="function">
<dt id="c.qemu_plugin_insn_haddr">
void * <code class="descname">qemu_plugin_insn_haddr</code><span class="sig-paren">(</span>const struct qemu_plugin_insn<em>&nbsp;*insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_haddr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return hardware addr of instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>opaque instruction handle from qemu_plugin_tb_get_insn()</dd>
</dl>
<p><strong>Return</strong></p>
<p>hardware (physical) target address of instruction</p>
<dl class="type">
<dt id="c.qemu_plugin_meminfo_t">
typedef <code class="descname">qemu_plugin_meminfo_t</code><a class="headerlink" href="#c.qemu_plugin_meminfo_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p>opaque memory transaction handle</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>This can be further queried using the qemu_plugin_mem_* query
functions.</p>
<dl class="function">
<dt id="c.qemu_plugin_mem_size_shift">
unsigned int <code class="descname">qemu_plugin_mem_size_shift</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a><em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_size_shift" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get size of access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt>
<dd>opaque memory transaction handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of access in ^2 (0=byte, 1=16bit, 2=32bit etcâ¦)</p>
<dl class="function">
<dt id="c.qemu_plugin_mem_is_sign_extended">
bool <code class="descname">qemu_plugin_mem_is_sign_extended</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a><em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_is_sign_extended" title="Permalink to this definition">Â¶</a></dt>
<dd><p>was the access sign extended</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt>
<dd>opaque memory transaction handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if it was, otherwise false</p>
<dl class="function">
<dt id="c.qemu_plugin_mem_is_big_endian">
bool <code class="descname">qemu_plugin_mem_is_big_endian</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a><em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_is_big_endian" title="Permalink to this definition">Â¶</a></dt>
<dd><p>was the access big endian</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt>
<dd>opaque memory transaction handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if it was, otherwise false</p>
<dl class="function">
<dt id="c.qemu_plugin_mem_is_store">
bool <code class="descname">qemu_plugin_mem_is_store</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a><em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_mem_is_store" title="Permalink to this definition">Â¶</a></dt>
<dd><p>was the access a store</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt>
<dd>opaque memory transaction handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if it was, otherwise false</p>
<dl class="function">
<dt id="c.qemu_plugin_get_hwaddr">
struct qemu_plugin_hwaddr * <code class="descname">qemu_plugin_get_hwaddr</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_meminfo_t" title="qemu_plugin_meminfo_t">qemu_plugin_meminfo_t</a><em>&nbsp;info</em>, uint64_t<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_get_hwaddr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return handle for memory operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_meminfo_t</span> <span class="pre">info</span></code></dt>
<dd>opaque memory info structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">vaddr</span></code></dt>
<dd>the virtual address of the memory operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>For system emulation returns a qemu_plugin_hwaddr handle to query
details about the actual physical address backing the virtual
address. For linux-user guests it just returns NULL.</p>
<p>This handle is <em>only</em> valid for the duration of the callback. Any
information about the handle should be recovered before the
callback returns.</p>
<dl class="function">
<dt id="c.qemu_plugin_hwaddr_is_io">
bool <code class="descname">qemu_plugin_hwaddr_is_io</code><span class="sig-paren">(</span>const struct qemu_plugin_hwaddr<em>&nbsp;*haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_hwaddr_is_io" title="Permalink to this definition">Â¶</a></dt>
<dd><p>query whether memory operation is IO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_hwaddr</span> <span class="pre">*haddr</span></code></dt>
<dd>address handle from qemu_plugin_get_hwaddr()</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the handleâs memory operation is to memory-mapped IO, or
false if it is to RAM</p>
<dl class="function">
<dt id="c.qemu_plugin_hwaddr_phys_addr">
uint64_t <code class="descname">qemu_plugin_hwaddr_phys_addr</code><span class="sig-paren">(</span>const struct qemu_plugin_hwaddr<em>&nbsp;*haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_hwaddr_phys_addr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>query physical address for memory operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_hwaddr</span> <span class="pre">*haddr</span></code></dt>
<dd>address handle from qemu_plugin_get_hwaddr()</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the physical address associated with the memory operation</p>
<p>Note that the returned physical address may not be unique if you are dealing
with multiple address spaces.</p>
<dl class="function">
<dt id="c.qemu_plugin_insn_disas">
char * <code class="descname">qemu_plugin_insn_disas</code><span class="sig-paren">(</span>const struct qemu_plugin_insn<em>&nbsp;*insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_disas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return disassembly string for instruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>instruction reference</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an allocated string containing the disassembly</p>
<dl class="function">
<dt id="c.qemu_plugin_insn_symbol">
const char * <code class="descname">qemu_plugin_insn_symbol</code><span class="sig-paren">(</span>const struct qemu_plugin_insn<em>&nbsp;*insn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_insn_symbol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>best effort symbol lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qemu_plugin_insn</span> <span class="pre">*insn</span></code></dt>
<dd>instruction reference</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a static string referring to the symbol. This is dependent
on the binary QEMU is running having provided a symbol table.</p>
<dl class="function">
<dt id="c.qemu_plugin_vcpu_for_each">
void <code class="descname">qemu_plugin_vcpu_for_each</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_vcpu_simple_cb_t" title="qemu_plugin_vcpu_simple_cb_t">qemu_plugin_vcpu_simple_cb_t</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_vcpu_for_each" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterate over the existing vCPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_vcpu_simple_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called once for each existing vCPU.</p>
<p>See also: qemu_plugin_register_vcpu_init_cb()</p>
<dl class="function">
<dt id="c.qemu_plugin_register_atexit_cb">
void <code class="descname">qemu_plugin_register_atexit_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#c.qemu_plugin_id_t" title="qemu_plugin_id_t">qemu_plugin_id_t</a><em>&nbsp;id</em>, <a class="reference internal" href="#c.qemu_plugin_udata_cb_t" title="qemu_plugin_udata_cb_t">qemu_plugin_udata_cb_t</a><em>&nbsp;cb</em>, void<em>&nbsp;*userdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_register_atexit_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register exit callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_id_t</span> <span class="pre">id</span></code></dt>
<dd>plugin ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qemu_plugin_udata_cb_t</span> <span class="pre">cb</span></code></dt>
<dd>callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*userdata</span></code></dt>
<dd>user data for callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>cb</strong> function is called once execution has finished. Plugins
should be able to free all their resources at this point much like
after a reset/uninstall callback is called.</p>
<p>In user-mode it is possible a few un-instrumented instructions from
child threads may run before the host kernel reaps the threads.</p>
<dl class="function">
<dt id="c.qemu_plugin_outs">
void <code class="descname">qemu_plugin_outs</code><span class="sig-paren">(</span>const char<em>&nbsp;*string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_outs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>output string via QEMUâs logging system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*string</span></code></dt>
<dd>a string</dd>
</dl>
<dl class="function">
<dt id="c.qemu_plugin_bool_parse">
bool <code class="descname">qemu_plugin_bool_parse</code><span class="sig-paren">(</span>const char<em>&nbsp;*name</em>, const char<em>&nbsp;*val</em>, bool<em>&nbsp;*ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.qemu_plugin_bool_parse" title="Permalink to this definition">Â¶</a></dt>
<dd><p>parses a boolean argument in the form of â&lt;argname&gt;=[on|yes|true|off|no|false]â</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>argument name, the part before the equals sign</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*val</span></code></dt>
<dd>argument value, whatâs after the equals sign</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*ret</span></code></dt>
<dd>output return value</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns true if the combination <strong>name**=**val</strong> parses correctly to a boolean
argument, and false otherwise</p>
</div>
</div>
<div class="section" id="internals">
<h2>Internals<a class="headerlink" href="#internals" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="locking">
<h3>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">Â¶</a></h3>
<p>We have to ensure we cannot deadlock, particularly under MTTCG. For
this we acquire a lock when called from plugin code. We also keep the
list of callbacks under RCU so that we do not have to hold the lock
when calling the callbacks. This is also for performance, since some
callbacks (e.g. memory access callbacks) might be called very
frequently.</p>
<blockquote>
<div><ul class="simple">
<li>A consequence of this is that we keep our own list of CPUs, so that
we do not have to worry about locking order wrt cpu_list_lock.</li>
<li>Use a recursive lock, since we can get registration calls from
callbacks.</li>
</ul>
</div></blockquote>
<p>As a result registering/unregistering callbacks is âslowâ, since it
takes a lock. But this is very infrequent; we want performance when
calling (or not calling) callbacks, not when registering them. Using
RCU is great for this.</p>
<p>We support the uninstallation of a plugin at any time (e.g. from
plugin callbacks). This allows plugins to remove themselves if they no
longer want to instrument the code. This operation is asynchronous
which means callbacks may still occur after the uninstall operation is
requested. The plugin isnât completely uninstalled until the safe work
has executed while all vCPUs are quiescent.</p>
</div>
</div>
<div class="section" id="example-plugins">
<h2>Example Plugins<a class="headerlink" href="#example-plugins" title="Permalink to this headline">Â¶</a></h2>
<p>There are a number of plugins included with QEMU and you are
encouraged to contribute your own plugins plugins upstream. There is a
<code class="docutils literal notranslate"><span class="pre">contrib/plugins</span></code> directory where they can go.</p>
<ul class="simple">
<li>tests/plugins</li>
</ul>
<p>These are some basic plugins that are used to test and exercise the
API during the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-tcg</span></code> target.</p>
<ul class="simple">
<li>contrib/plugins/hotblocks.c</li>
</ul>
<p>The hotblocks plugin allows you to examine the where hot paths of
execution are in your program. Once the program has finished you will
get a sorted list of blocks reporting the starting PC, translation
count, number of instructions and execution count. This will work best
with linux-user execution as system emulation tends to generate
re-translations as blocks from different programs get swapped in and
out of system memory.</p>
<p>If your program is single-threaded you can use the <code class="docutils literal notranslate"><span class="pre">inline</span></code> option for
slightly faster (but not thread safe) counters.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">qemu</span><span class="o">-</span><span class="n">aarch64</span> \
  <span class="o">-</span><span class="n">plugin</span> <span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">libhotblocks</span><span class="o">.</span><span class="n">so</span> <span class="o">-</span><span class="n">d</span> <span class="n">plugin</span> \
  <span class="o">./</span><span class="n">tests</span><span class="o">/</span><span class="n">tcg</span><span class="o">/</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">sha1</span>
<span class="n">SHA1</span><span class="o">=</span><span class="mi">15</span><span class="n">dd99a1991e0b3826fede3deffc1feba42278e6</span>
<span class="n">collected</span> <span class="mi">903</span> <span class="n">entries</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">hash</span> <span class="n">table</span>
<span class="n">pc</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">icount</span><span class="p">,</span> <span class="n">ecount</span>
<span class="mh">0x0000000041ed10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">66087</span>
<span class="mh">0x000000004002b0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">66087</span>
<span class="o">...</span>
</pre></div>
</div>
<ul class="simple">
<li>contrib/plugins/hotpages.c</li>
</ul>
<p>Similar to hotblocks but this time tracks memory accesses:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">qemu</span><span class="o">-</span><span class="n">aarch64</span> \
  <span class="o">-</span><span class="n">plugin</span> <span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">libhotpages</span><span class="o">.</span><span class="n">so</span> <span class="o">-</span><span class="n">d</span> <span class="n">plugin</span> \
  <span class="o">./</span><span class="n">tests</span><span class="o">/</span><span class="n">tcg</span><span class="o">/</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">sha1</span>
<span class="n">SHA1</span><span class="o">=</span><span class="mi">15</span><span class="n">dd99a1991e0b3826fede3deffc1feba42278e6</span>
<span class="n">Addr</span><span class="p">,</span> <span class="n">RCPUs</span><span class="p">,</span> <span class="n">Reads</span><span class="p">,</span> <span class="n">WCPUs</span><span class="p">,</span> <span class="n">Writes</span>
<span class="mh">0x000055007fe000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">31747952</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">8835161</span>
<span class="mh">0x000055007ff000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">29001054</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">8780625</span>
<span class="mh">0x00005500800000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">687465</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">335857</span>
<span class="mh">0x0000000048b000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">130594</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">355</span>
<span class="mh">0x0000000048a000</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">1826</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="mi">11</span>
</pre></div>
</div>
<p>The hotpages plugin can be configured using the following arguments:</p>
<blockquote>
<div><ul class="simple">
<li>sortby=reads|writes|address</li>
</ul>
<p>Log the data sorted by either the number of reads, the number of writes, or
memory address. (Default: entries are sorted by the sum of reads and writes)</p>
<ul class="simple">
<li>io=on</li>
</ul>
<p>Track IO addresses. Only relevant to full system emulation. (Default: off)</p>
<ul class="simple">
<li>pagesize=N</li>
</ul>
<p>The page size used. (Default: N = 4096)</p>
</div></blockquote>
<ul class="simple">
<li>contrib/plugins/howvec.c</li>
</ul>
<p>This is an instruction classifier so can be used to count different
types of instructions. It has a number of options to refine which get
counted. You can give a value to the <cite>count</cite> argument for a class of
instructions to break it down fully, so for example to see all the system
registers accesses:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>./aarch64-softmmu/qemu-system-aarch64 $(QEMU_ARGS) \
  -append &quot;root=/dev/sda2 systemd.unit=benchmark.service&quot; \
  -smp 4 -plugin ./contrib/plugins/libhowvec.so,count=sreg -d plugin
</pre></div>
</div>
<p>which will lead to a sorted list after the class breakdown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="n">Classes</span><span class="p">:</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">UDEF</span>                   <span class="ow">not</span> <span class="n">counted</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">SVE</span>                    <span class="p">(</span><span class="mi">68</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">PCrel</span> <span class="n">addr</span>             <span class="p">(</span><span class="mi">47789483</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Add</span><span class="o">/</span><span class="n">Sub</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>          <span class="p">(</span><span class="mi">192817388</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Logical</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>          <span class="p">(</span><span class="mi">93852565</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Move</span> <span class="n">Wide</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>        <span class="p">(</span><span class="mi">76398116</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Bitfield</span>               <span class="p">(</span><span class="mi">44706084</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Extract</span>                <span class="p">(</span><span class="mi">5499257</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Cond</span> <span class="n">Branch</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>      <span class="p">(</span><span class="mi">147202932</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="ne">Exception</span> <span class="n">Gen</span>          <span class="p">(</span><span class="mi">193581</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>     <span class="n">NOP</span>                  <span class="ow">not</span> <span class="n">counted</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Hints</span>                  <span class="p">(</span><span class="mi">6652291</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Barriers</span>               <span class="p">(</span><span class="mi">8001661</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">PSTATE</span>                 <span class="p">(</span><span class="mi">1801695</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">System</span> <span class="n">Insn</span>            <span class="p">(</span><span class="mi">6385349</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">System</span> <span class="n">Reg</span>             <span class="n">counted</span> <span class="n">individually</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Branch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>           <span class="p">(</span><span class="mi">69497127</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Branch</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>           <span class="p">(</span><span class="mi">84393665</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Cmp</span> <span class="o">&amp;</span> <span class="n">Branch</span>           <span class="p">(</span><span class="mi">110929659</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Tst</span> <span class="o">&amp;</span> <span class="n">Branch</span>           <span class="p">(</span><span class="mi">44681442</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">AdvSimd</span> <span class="n">ldstmult</span>       <span class="p">(</span><span class="mi">736</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">excl</span>              <span class="p">(</span><span class="mi">9098783</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">Load</span> <span class="n">Reg</span> <span class="p">(</span><span class="n">lit</span><span class="p">)</span>         <span class="p">(</span><span class="mi">87189424</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">noalloc</span> <span class="n">pair</span>      <span class="p">(</span><span class="mi">3264433</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">pair</span>              <span class="p">(</span><span class="mi">412526434</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span>   <span class="n">ldst</span> <span class="n">reg</span> <span class="p">(</span><span class="n">imm</span><span class="p">)</span>         <span class="p">(</span><span class="mi">314734576</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span> <span class="n">Loads</span> <span class="o">&amp;</span> <span class="n">Stores</span>           <span class="p">(</span><span class="mi">2117774</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span> <span class="n">Data</span> <span class="n">Proc</span> <span class="n">Reg</span>            <span class="p">(</span><span class="mi">223519077</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Class</span><span class="p">:</span> <span class="n">Scalar</span> <span class="n">FP</span>                <span class="p">(</span><span class="mi">31657954</span> <span class="n">hits</span><span class="p">)</span>
<span class="n">Individual</span> <span class="n">Instructions</span><span class="p">:</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x0</span><span class="p">,</span> <span class="n">sp_el0</span>           <span class="p">(</span><span class="mi">2682661</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd5384100</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x1</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">1789339</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd041</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x2</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">1513494</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd042</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x0</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">1490823</span> <span class="n">hits</span><span class="p">)</span>  <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd040</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x1</span><span class="p">,</span> <span class="n">sp_el0</span>           <span class="p">(</span><span class="mi">933793</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd5384101</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x2</span><span class="p">,</span> <span class="n">sp_el0</span>           <span class="p">(</span><span class="mi">699516</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd5384102</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x4</span><span class="p">,</span> <span class="n">tpidr_el2</span>        <span class="p">(</span><span class="mi">528437</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd53cd044</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">mrs</span> <span class="n">x30</span><span class="p">,</span> <span class="n">ttbr1_el1</span>       <span class="p">(</span><span class="mi">480776</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd538203e</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">msr</span> <span class="n">ttbr1_el1</span><span class="p">,</span> <span class="n">x30</span>       <span class="p">(</span><span class="mi">480713</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd518203e</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="n">Instr</span><span class="p">:</span> <span class="n">msr</span> <span class="n">vbar_el1</span><span class="p">,</span> <span class="n">x30</span>        <span class="p">(</span><span class="mi">480671</span> <span class="n">hits</span><span class="p">)</span>   <span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="mh">0xd518c01e</span><span class="o">/</span>  <span class="n">System</span> <span class="n">Reg</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>To find the argument shorthand for the class you need to examine the
source code of the plugin at the moment, specifically the <code class="docutils literal notranslate"><span class="pre">*opt</span></code>
argument in the InsnClassExecCount tables.</p>
<ul class="simple">
<li>contrib/plugins/lockstep.c</li>
</ul>
<p>This is a debugging tool for developers who want to find out when and
where execution diverges after a subtle change to TCG code generation.
It is not an exact science and results are likely to be mixed once
asynchronous events are introduced. While the use of -icount can
introduce determinism to the execution flow it doesnât always follow
the translation sequence will be exactly the same. Typically this is
caused by a timer firing to service the GUI causing a block to end
early. However in some cases it has proved to be useful in pointing
people at roughly where execution diverges. The only argument you need
for the plugin is a path for the socket the two instances will
communicate over:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">sparc</span><span class="o">-</span><span class="n">softmmu</span><span class="o">/</span><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">sparc</span> <span class="o">-</span><span class="n">monitor</span> <span class="n">none</span> <span class="o">-</span><span class="n">parallel</span> <span class="n">none</span> \
  <span class="o">-</span><span class="n">net</span> <span class="n">none</span> <span class="o">-</span><span class="n">M</span> <span class="n">SS</span><span class="o">-</span><span class="mi">20</span> <span class="o">-</span><span class="n">m</span> <span class="mi">256</span> <span class="o">-</span><span class="n">kernel</span> <span class="n">day11</span><span class="o">/</span><span class="n">zImage</span><span class="o">.</span><span class="n">elf</span> \
  <span class="o">-</span><span class="n">plugin</span> <span class="o">./</span><span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">liblockstep</span><span class="o">.</span><span class="n">so</span><span class="p">,</span><span class="n">sockpath</span><span class="o">=</span><span class="n">lockstep</span><span class="o">-</span><span class="n">sparc</span><span class="o">.</span><span class="n">sock</span> \
<span class="o">-</span><span class="n">d</span> <span class="n">plugin</span><span class="p">,</span><span class="n">nochain</span>
</pre></div>
</div>
<p>which will eventually report:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">sparc</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="n">nic</span> <span class="n">lance</span><span class="o">.</span><span class="mi">0</span> <span class="n">has</span> <span class="n">no</span> <span class="n">peer</span>
<span class="o">@</span> <span class="mh">0x000000ffd06678</span> <span class="n">vs</span> <span class="mh">0x000000ffd001e0</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">1</span> <span class="n">since</span> <span class="n">last</span><span class="p">)</span>
<span class="o">@</span> <span class="mh">0x000000ffd07d9c</span> <span class="n">vs</span> <span class="mh">0x000000ffd06678</span> <span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">1</span> <span class="n">since</span> <span class="n">last</span><span class="p">)</span>
<span class="n">Î</span> <span class="n">insn_count</span> <span class="o">@</span> <span class="mh">0x000000ffd07d9c</span> <span class="p">(</span><span class="mi">809900609</span><span class="p">)</span> <span class="n">vs</span> <span class="mh">0x000000ffd06678</span> <span class="p">(</span><span class="mi">809900612</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd06678</span><span class="o">/</span><span class="mi">10</span> <span class="p">(</span><span class="mi">809900609</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd001e0</span><span class="o">/</span><span class="mi">4</span> <span class="p">(</span><span class="mi">809900599</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd080ac</span><span class="o">/</span><span class="mi">2</span> <span class="p">(</span><span class="mi">809900595</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd08098</span><span class="o">/</span><span class="mi">5</span> <span class="p">(</span><span class="mi">809900593</span> <span class="n">insns</span><span class="p">)</span>
  <span class="n">previously</span> <span class="o">@</span> <span class="mh">0x000000ffd080c0</span><span class="o">/</span><span class="mi">1</span> <span class="p">(</span><span class="mi">809900588</span> <span class="n">insns</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>contrib/plugins/hwprofile.c</li>
</ul>
<p>The hwprofile tool can only be used with system emulation and allows
the user to see what hardware is accessed how often. It has a number of options:</p>
<blockquote>
<div><ul class="simple">
<li>track=read or track=write</li>
</ul>
<p>By default the plugin tracks both reads and writes. You can use one
of these options to limit the tracking to just one class of accesses.</p>
<ul class="simple">
<li>source</li>
</ul>
<p>Will include a detailed break down of what the guest PC that made the
access was. Not compatible with the pattern option. Example output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cirrus</span><span class="o">-</span><span class="n">low</span><span class="o">-</span><span class="n">memory</span> <span class="o">@</span> <span class="mh">0xfffffd00000a0000</span>
 <span class="n">pc</span><span class="p">:</span><span class="n">fffffc0000005cdc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span>
 <span class="n">pc</span><span class="p">:</span><span class="n">fffffc0000005ce8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span>
 <span class="n">pc</span><span class="p">:</span><span class="n">fffffc0000005cec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span>
</pre></div>
</div>
<ul class="simple">
<li>pattern</li>
</ul>
<p>Instead break down the accesses based on the offset into the HW
region. This can be useful for seeing the most used registers of a
device. Example output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pci0</span><span class="o">-</span><span class="n">conf</span> <span class="o">@</span> <span class="mh">0xfffffd01fe000000</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000004</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000014</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000018</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">0000001</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="n">off</span><span class="p">:</span><span class="mi">00000020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
  <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li>contrib/plugins/execlog.c</li>
</ul>
<p>The execlog tool traces executed instructions with memory access. It can be used
for debugging and security analysis purposes.
Please be aware that this will generate a lot of output.</p>
<p>The plugin takes no argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>qemu-system-arm $(QEMU_ARGS) \
  -plugin ./contrib/plugins/libexeclog.so -d plugin
</pre></div>
</div>
<p>which will output an execution trace following this structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># vCPU, vAddr, opcode, disassembly[, load/store, memory addr, device]...</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xa12</span><span class="p">,</span> <span class="mh">0xf8012400</span><span class="p">,</span> <span class="s2">&quot;movs r4, #0&quot;</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xa14</span><span class="p">,</span> <span class="mh">0xf87f42b4</span><span class="p">,</span> <span class="s2">&quot;cmp r4, r6&quot;</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xa16</span><span class="p">,</span> <span class="mh">0xd206</span><span class="p">,</span> <span class="s2">&quot;bhs #0xa26&quot;</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xa18</span><span class="p">,</span> <span class="mh">0xfff94803</span><span class="p">,</span> <span class="s2">&quot;ldr r0, [pc, #0xc]&quot;</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="mh">0x00010a28</span><span class="p">,</span> <span class="n">RAM</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xa1a</span><span class="p">,</span> <span class="mh">0xf989f000</span><span class="p">,</span> <span class="s2">&quot;bl #0xd30&quot;</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xd30</span><span class="p">,</span> <span class="mh">0xfff9b510</span><span class="p">,</span> <span class="s2">&quot;push {r4, lr}&quot;</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="mh">0x20003ee0</span><span class="p">,</span> <span class="n">RAM</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="mh">0x20003ee4</span><span class="p">,</span> <span class="n">RAM</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xd32</span><span class="p">,</span> <span class="mh">0xf9893014</span><span class="p">,</span> <span class="s2">&quot;adds r0, #0x14&quot;</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0xd34</span><span class="p">,</span> <span class="mh">0xf9c8f000</span><span class="p">,</span> <span class="s2">&quot;bl #0x10c8&quot;</span>
<span class="mi">0</span><span class="p">,</span> <span class="mh">0x10c8</span><span class="p">,</span> <span class="mh">0xfff96c43</span><span class="p">,</span> <span class="s2">&quot;ldr r3, [r0, #0x44]&quot;</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="mh">0x200000e4</span><span class="p">,</span> <span class="n">RAM</span>
</pre></div>
</div>
<ul class="simple">
<li>contrib/plugins/cache.c</li>
</ul>
<p>Cache modelling plugin that measures the performance of a given cache
configuration when a given working set is run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qemu</span><span class="o">-</span><span class="n">x86_64</span> <span class="o">-</span><span class="n">plugin</span> <span class="o">./</span><span class="n">contrib</span><span class="o">/</span><span class="n">plugins</span><span class="o">/</span><span class="n">libcache</span><span class="o">.</span><span class="n">so</span> \
  <span class="o">-</span><span class="n">d</span> <span class="n">plugin</span> <span class="o">-</span><span class="n">D</span> <span class="n">cache</span><span class="o">.</span><span class="n">log</span> <span class="o">./</span><span class="n">tests</span><span class="o">/</span><span class="n">tcg</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">user</span><span class="o">/</span><span class="n">float_convs</span>
</pre></div>
</div>
<p>will report the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>core #, data accesses, data misses, dmiss rate, insn accesses, insn misses, imiss rate
0       996695         508             0.0510%  2642799        18617           0.7044%

address, data misses, instruction
0x424f1e (_int_malloc), 109, movq %rax, 8(%rcx)
0x41f395 (_IO_default_xsputn), 49, movb %dl, (%rdi, %rax)
0x42584d (ptmalloc_init.part.0), 33, movaps %xmm0, (%rax)
0x454d48 (__tunables_init), 20, cmpb $0, (%r8)
...

address, fetch misses, instruction
0x4160a0 (__vfprintf_internal), 744, movl $1, %ebx
0x41f0a0 (_IO_setb), 744, endbr64
0x415882 (__vfprintf_internal), 744, movq %r12, %rdi
0x4268a0 (__malloc), 696, andq $0xfffffffffffffff0, %rax
...
</pre></div>
</div>
<p>The plugin has a number of arguments, all of them are optional:</p>
<blockquote>
<div><ul class="simple">
<li>limit=N</li>
</ul>
<p>Print top N icache and dcache thrashing instructions along with their
address, number of misses, and its disassembly. (default: 32)</p>
<ul class="simple">
<li>icachesize=N</li>
<li>iblksize=B</li>
<li>iassoc=A</li>
</ul>
<p>Instruction cache configuration arguments. They specify the cache size, block
size, and associativity of the instruction cache, respectively.
(default: N = 16384, B = 64, A = 8)</p>
<ul class="simple">
<li>dcachesize=N</li>
<li>dblksize=B</li>
<li>dassoc=A</li>
</ul>
<p>Data cache configuration arguments. They specify the cache size, block size,
and associativity of the data cache, respectively.
(default: N = 16384, B = 64, A = 8)</p>
<ul class="simple">
<li>evict=POLICY</li>
</ul>
<p>Sets the eviction policy to POLICY. Available policies are: <code class="code docutils literal notranslate"><span class="pre">lru</span></code>,
<code class="code docutils literal notranslate"><span class="pre">fifo</span></code>, and <code class="code docutils literal notranslate"><span class="pre">rand</span></code>. The plugin will use the specified policy for
both instruction and data caches. (default: POLICY = <code class="code docutils literal notranslate"><span class="pre">lru</span></code>)</p>
<ul class="simple">
<li>cores=N</li>
</ul>
<p>Sets the number of cores for which we maintain separate icache and dcache.
(default: for linux-user, N = 1, for full system emulation: N = cores
available to guest)</p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bitops.html" class="btn btn-neutral float-right" title="Bitwise operations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="multi-thread-tcg.html" class="btn btn-neutral float-left" title="Multi-threaded TCG" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, The QEMU Project Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 6.1.50.</p>


<p><a href="../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>